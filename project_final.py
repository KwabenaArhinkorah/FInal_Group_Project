# -*- coding: utf-8 -*-
"""Project final

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_wqUzcqqjKqgR-dGsuQHdKCdLyCfv4p0

# Loading Data and Imports
"""

!pip install scikeras

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import seaborn as sns
import nltk
import string
import re
import matplotlib.pyplot as plt
plt.style.use('ggplot')
from sklearn.metrics import roc_curve, auc
from sklearn.metrics import classification_report, confusion_matrix
from nltk.corpus import stopwords
from nltk.stem import PorterStemmer
from sklearn.model_selection import train_test_split
from mlxtend.plotting import plot_confusion_matrix
import matplotlib.cm as cm
from matplotlib import rcParams
from collections import Counter
from nltk.tokenize import RegexpTokenizer
from tensorflow.keras.layers import LSTM, Activation, Dense, Dropout, Input, Embedding
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import RMSprop, Adam
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing import sequence
from keras.regularizers import l1_l2
# %matplotlib inline

from google.colab import drive
drive.mount('/content/drive')

df=pd.read_csv('/content/drive/My Drive/AIClass/trainingdata.csv', encoding = "ISO-8859-1", engine="python")

df=pd.read_csv('/content/trainingdata.csv', encoding = "ISO-8859-1", engine="python")

"""#  EDA"""

df.head()

df.columns

df.shape

df.info()

df.dtypes

"""Checking null values"""

np.sum(df.isnull().any(axis=1))

"""We will impute null values"""

most_frequent_label = df['sentiments'].value_counts().idxmax()
df['sentiments'] = df['sentiments'].fillna(most_frequent_label)

df

# sanity check
np.sum(df.isnull().any(axis=1))

"""## Data Preparation

For our data we need to clean and remove stop words. Stop words are words that does not contribute semantic meaning to a piece of text.

We also apply stemming, lemmatization and tokenization. This are efficient steps to ensure a good sentiment analysis.

Convert sentences to lowercase strings
"""

df['sentences']=df['sentences'].str.lower()

df['sentences'].tail()

"""Cleaning and removing stop words"""

nltk.download('stopwords')
stop_words = stopwords.words('english')

"""In Eglish the stop words we have are:"""

', '.join(stopwords.words('english'))

"""Now we will remove the stop words in our sentences"""

STOPWORDS = set(stopwords.words('english'))

def cleaning_stopwords(text):
  '''
    Removes the stopwords in a text
  '''

  return " ".join([word for word in str(text).split() if word not in STOPWORDS])

"""Over here we will apply my `cleaning_stopwords` function aynchronously using `lambda` on each sentence in our dataframe"""

df['sentences'] = df['sentences'].apply(lambda text: cleaning_stopwords(text))
df['sentences'].head()

"""Also punctuations also don't contribute much to meaning in a text. Thus we use the python `string` module and we removes punctations found in our sentences."""

def cleaning_punctuations(text):
    # Remove punctuation from the text
    translator = str.maketrans('', '', string.punctuation)
    cleaned_text = text.translate(translator)
    return cleaned_text

"""We use the same asynchronous approach for removing stopwords to remove punctuations"""

df['sentences']= df['sentences'].apply(lambda x: cleaning_punctuations(x))
df['sentences'].head()

"""## Data Viz"""

plt.figure(figsize=(12,6))
sns.countplot(x='sentiments',data=df)

"""# Feature Engineering

For a sentiment analysis task the feature engineering step involves the following;


1.   Tokenization
2.   Stemming
3.   Lemmatization

## Tokenization
In NLP tokenization is the process of breaking down text into smaller units called tokens. Tokens can be words, numbers or punctuation marks.

*Purpose*: It helps in understanding the context or developing the structure of the text data. This process is essential for tasks like word count, frequency distribution, and is a precursor for further text processing activities.

*Example*: The sentence "ChatGPT is amazing!" would be tokenized into ["ChatGPT", "is", "amazing", "!"].

In our work, we tokenize on words. So we specify a regex pattern `w+`- which returns a word bound in a sentence
"""

#tokenize sentences into words
tokenizer = RegexpTokenizer(r'\w+') #specify word boundary using regex

#applying on dataframe
df['sentences'] = df['sentences'].apply(tokenizer.tokenize)
df['sentences'].head()

texts = df.sentences
unique_words = set()

for tokens in texts:
  unique_words.update(tokens)

unique_words

vocab_size = len(unique_words)
vocab_size

"""## Stemming

Stemming is a process of reducing words to their base or root form. The idea is to remove suffixes from words to obtain a form that is not necessarily a dictionary-based word but a simplified version of the word.

*Purpose*: It is used in indexing, search algorithms, and text analysis. Stemming helps in reducing the complexity of the text and in improving search accuracy and relevance.

*Example*: The words "running", "runner", and "ran" might all be stemmed to the root "run".

We are using the Porter Stemmer algorithm: A word stemmer based on the Porter stemming algorithm. From the nltk module
"""

#set stemmer
st = nltk.PorterStemmer()
#simple function to do stemming
def stemming_on_text(data):
    text = [st.stem(word) for word in data]
    return data

"""Applying stemming on dataset"""

df['sentences']= df['sentences'].apply(lambda x: stemming_on_text(x))
df['sentences'].head()

"""## Lemmatization

Lemmatization is a more sophisticated approach than stemming. It involves reducing a word to its base or root form, but this root form (lemma) is always a valid dictionary word.

Lemmatization considers the context and converts the word to its meaningful base form.

*Purpose*: It is used in comprehensive linguistic processing tasks. Lemmatization is preferred where accurate text representation is necessary, such as in search engines, text analysis, and natural language understanding applications.

*Example*: The words "am", "are", and "is" are lemmatized to the lemma "be".

We use the WordNetLemmatizer from nltk
"""

#download wordnet
nltk.download("wordnet")

lm = nltk.WordNetLemmatizer()
def lemmatizer_on_text(data):
    text = [lm.lemmatize(word) for word in data]
    return data

"""Applying lemmatization on dataset"""

df['sentences']= df['sentences'].apply(lambda x: lemmatizer_on_text(x))
df['sentences'].head()

"""# Training of Models

Before the training of our models, let's clarify some terms in our project.

* **Sentiments/Labels**: sentiments are the targets like in this project senitments of the student reviews.

* **Inputs/Features** : Inputs are the data that we feed into machine learning like in this project tweets texts are the inputs.

* **Training Data**: We use training data when we train the models. We feed train data to machine learning and deep learning models so that model can learn from the data.

* **Validation Data**: We use validation data while training the model. We use this data to evalaute the performance that how the model perform on training time.

* **Testing Data**: We use testing data after training the model. We use this data to evalaute the performance that how the model perform after training. So in this way first we get predictions from the trained model without giving the labels and then we compare the true labels with predictions and get the performance of th model..

## Feature Extraction


We are going to separate our target feature from our input feature as we prepare to train.

But before we do that; we hope to train with the `spares_categorical_crossentropy` loss from keras for multiclass classification. Thus we are going to re-map the sentiments for our target feature.

1. `postive == 1.0 --> 1`
2. `neutral == 0.0 --> 0`
3. `negative == -1 --> 2`
"""

df['labels'] = df['sentiments'].map({-1: 2, 0: 0, 1: 1})

df['labels'].head()

df

X=df.sentences
y=df.labels #we use encoded labels to train

"""Next what we do is

1. Convert our sentences(feature engineered) into an array form
2. Then we subset a maximum of 500 words as our features for training. These 500 words will be selected on the importance that will distinguish between the positive, neutral and negative feedback.
"""

max_len = 500
tok = Tokenizer(num_words=vocab_size)
tok.fit_on_texts(X)
sequences = tok.texts_to_sequences(X)
sequences_matrix = sequence.pad_sequences(sequences,maxlen=max_len)

sequences_matrix.shape

"""As the shape method showed we have `1301` student feedbacks and the number/words or features we are focusing we focusing on are `500`

Splitting Data:
"""

X_train, X_test, Y_train, Y_test = train_test_split(sequences_matrix, y, test_size=0.2, random_state=45)

"""## Training

## LSTM

Our first attempt is to train an LSTM model for sentiment classification. Below we define the layers of our model:
"""

inputs = Input(name='inputs',shape=[max_len])
layer = Embedding(vocab_size+1,100,input_length=max_len)(inputs)
layer = LSTM(64)(layer)
layer = Dense(256,name='FC1', kernel_regularizer=l1_l2(l1=0.01, l2=0.01))(layer)
layer = Activation('relu')(layer)
layer = Dropout(0.5)(layer)
layer = Dense(3,name='out_layer')(layer)
layer = Activation('softmax')(layer)
model = Model(inputs=inputs,outputs=layer)

model.compile(
    loss='sparse_categorical_crossentropy',
    optimizer=Adam(learning_rate=0.0001),
    metrics=['accuracy'])

from keras.callbacks import EarlyStopping
early_stopping = EarlyStopping(monitor='val_loss', patience=5)

history=model.fit(
    X_train,
    Y_train,
    batch_size=16,
    epochs=25,
    validation_split=0.1,
    callbacks=early_stopping)

"""### Metrics

#### Losses

We are going to plot our *training loss* vs. *validation loss* to see how they compare.
"""

training_loss = history.history['loss']
validation_loss = history.history['val_loss']

# Set up the number of epochs as the x-axis
epochs = range(1, len(training_loss) + 1)

# Plot training and validation loss
plt.figure(figsize=(10, 6))
plt.plot(epochs, training_loss, label='Training loss')  # 'bo' gives blue dot
plt.plot(epochs, validation_loss, label='Validation loss')  # 'b' gives solid blue line
plt.title('Training and Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()

plt.show()

"""#### Accuracy"""

training_acc = history.history['accuracy']
validation_acc = history.history['val_accuracy']

# Set up the number of epochs as the x-axis
epochs = range(1, len(training_loss) + 1)

# Plot training and validation loss
plt.figure(figsize=(10, 6))
plt.plot(epochs, training_acc, label='Training Accuracy')  # 'bo' gives blue dot
plt.plot(epochs, validation_acc, label='Validation Accuracy')  # 'b' gives solid blue line
plt.title('Training and Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()

plt.show()

accr1 = model.evaluate(X_test,Y_test) #we are starting to test the model here

"""### Conclusion

We observe that at around the 20th epoch the model begins to over fit. Since from the two graphs at the 20th the epoch training loss becomes smaller than validation loss and training accuracy grows quickly than validation accuracy.

With this performing a grid search is not guranteed to give a better set of parameters.

We are achieve an `Accuracy: 60%`. We are pivoting to an approach using prerained BERT Model.

## BERT with NeMo
"""

# install NeMo
BRANCH = 'main'
!python -m pip install git+https://github.com/NVIDIA/NeMo.git@$BRANCH#egg=nemo_toolkit[nlp]

from nemo.collections import nlp as nemo_nlp
from nemo.utils.exp_manager import exp_manager

import os
import wget
import torch
import pytorch_lightning as pl
from omegaconf import OmegaConf

"""### NeMo Text Classification Data Format

[TextClassificationModel](https://github.com/NVIDIA/NeMo/blob/main/nemo/collections/nlp/models/text_classification/text_classification_model.py) in NeMo supports text classification problems such as sentiment analysis or domain/intent detection for dialogue systems, as long as the data follows the format specified below.

TextClassificationModel requires the data to be stored in TAB separated files (.tsv) with two columns of sentence and label. Each line of the data file contains text sequences, where words are separated with spaces and label separated with [TAB], i.e.:

```
[WORD][SPACE][WORD][SPACE][WORD][TAB][LABEL]
```

For example:
```
hide new secretions from the parental units[TAB]0

that loves its characters and communicates something rather beautiful about human nature[TAB]1
...
```


If your dataset is stored in another format, you need to convert it to this format to use the TextClassificationModel.

We are going to convert our dataset into a `.tsv` format
"""

!mkdir DATA_DIR

PROJECT_FOLDER = "/content/"


DATA_DIR = PROJECT_FOLDER + "DATA_DIR"
WORK_DIR = PROJECT_FOLDER + "WORK_DIR"
os.environ['DATA_DIR'] = DATA_DIR

df_csv=pd.read_csv('/content/trainingdata.csv', encoding = "ISO-8859-1", engine="python")

len(df_csv)

df_csv.dropna(axis=0, inplace=True)

len(df_csv)

df_csv['sentiments'] = df['sentiments'].astype('int32')

#swapping sentiments abd sentences
df_csv['sentences'], df_csv['sentiments'] = df_csv['sentiments'], df_csv['sentences']

df_csv.head()

# First, split into train (75%) and the remaining (25%)
train_df, remaining_df = train_test_split(df_csv, test_size=0.25, random_state=42)

# Then split the remaining into test (15%) and dev (10%) from the original data
# Calculate the proportion of remaining_df for test to match 15% of the original data
test_ratio = 0.15 / 0.25
test_df, dev_df = train_test_split(remaining_df, test_size=test_ratio, random_state=42)

"""Saving the files"""

train_df.to_csv('DATA_DIR/train.tsv', sep='\t', header=False,  index=False)
test_df.to_csv('DATA_DIR/test.tsv', sep='\t',header=False, index=False)
dev_df.to_csv('DATA_DIR/dev.tsv', sep='\t',header=False, index=False)

"""### Load Presaved  """

# Define your column names
column_names = ['sentence', 'label']  # Replace with your column names

# Load the dataset
dev_tsv = pd.read_csv('/content/DATA_DIR/dev.tsv', sep='\t',header=None, names=column_names)
test_tsv = pd.read_csv('/content/DATA_DIR/test.tsv', sep='\t',header=None, names=column_names)
train_tsv = pd.read_csv('/content/DATA_DIR/train.tsv', sep='\t',header=None, names=column_names)

dev_tsv.head()

dev_tsv['sentiments'] = dev_tsv['label'].map({-1: 2, 0: 0, 1: 1})
test_tsv['sentiments'] = test_tsv['label'].map({-1: 2, 0: 0, 1: 1})
train_tsv['sentiments'] = train_tsv['label'].map({-1: 2, 0: 0, 1: 1})

dev_tsv.head()

#drop label column
dev_tsv.drop('label', axis=1, inplace=True)
test_tsv.drop('label', axis=1, inplace=True)
train_tsv.drop('label', axis=1, inplace=True)

dev_tsv.head()

"""Saving model with updated classes"""

train_tsv.to_csv('DATA_DIR/train.tsv', sep='\t', header=False,  index=False)
test_tsv.to_csv('DATA_DIR/test.tsv', sep='\t',header=False, index=False)
dev_tsv.to_csv('DATA_DIR/dev.tsv', sep='\t',header=False, index=False)

"""### Model Configuration

Now, let's take a closer look at the model's configuration and learn to train the model from scratch and finetune the pretrained model.

Our text classification model uses a pretrained [BERT](https://arxiv.org/pdf/1810.04805.pdf) model (or other BERT-like models) followed by a classification layer on the output of the first token ([CLS]).

The model is defined in a config file which declares multiple important sections. The most important ones are:
- **model**: All arguments that are related to the Model - language model, tokenizer, head classifier, optimizer, schedulers, and datasets/data loaders.

- **trainer**: Any argument to be passed to PyTorch Lightning including number of epochs, number of GPUs, precision level, etc.
"""

# download the model's configuration file
MODEL_CONFIG = "text_classification_config.yaml"
CONFIG_DIR = WORK_DIR + '/configs/'

os.makedirs(CONFIG_DIR, exist_ok=True)
if not os.path.exists(CONFIG_DIR + MODEL_CONFIG):
    print('Downloading config file...')
    wget.download(f'https://raw.githubusercontent.com/NVIDIA/NeMo/{BRANCH}/examples/nlp/text_classification/conf/' + MODEL_CONFIG, CONFIG_DIR)
    print('Config file downloaded!')
else:
    print ('config file already exists')
config_path = f'{WORK_DIR}/configs/{MODEL_CONFIG}'
print(config_path)
config = OmegaConf.load(config_path)

print(OmegaConf.to_yaml(config))

"""### Model Training From Scratch


##### Setting up data within the config

We first need to set the num_classes in the config file which specifies the number of classes in the dataset. For this dat, we have just three classes (-1-negative, 0-neutral and 1-positive). So we set the num_classes to 3.
"""

config.model.dataset.num_classes=3

"""Among other things, the config file contains dictionaries called dataset, train_ds and validation_ds. These are configurations used to setup the Dataset and DataLoaders of the corresponding config.

Notice that some config lines, including `model.dataset.classes_num`, have `???` as their value, this means that values for these fields are required to be to be specified by the user. We need to specify and set the `model.train_ds.file_name`, `model.validation_ds.file_name`, and `model.test_ds.file_name` in the config file to the paths of the train, validation, and test files if they exist. We may do it by updating the config file or by setting them from the command line.

Let's now set the train and validation paths in the config.
"""

config.model.train_ds.file_path = os.path.join(DATA_DIR, 'train.tsv')
config.model.validation_ds.file_path = os.path.join(DATA_DIR, 'dev.tsv')
# Name of the .nemo file where trained model will be saved.
config.save_to = 'trained-model.nemo'
config.export_to = 'trained-model.onnx'

print("Train dataloader's config: \n")
# OmegaConf.to_yaml() is used to create a proper format for printing the train dataloader's config
# You may change other params like batch size or the number of samples to be considered (-1 means all the samples)
print(OmegaConf.to_yaml(config.model.train_ds))

"""#### Building the PyTorch Lightning Trainer

NeMo models are primarily PyTorch Lightning (PT) modules - and therefore are entirely compatible with the PyTorch Lightning ecosystem.

Let's first instantiate a PT Trainer object by using the trainer section of the config.
"""

print("Trainer config - \n")
# OmegaConf.to_yaml() is used to create a proper format for printing the trainer config
print(OmegaConf.to_yaml(config.trainer))

"""First you need to create a PT trainer with the params stored in the trainer's config. You may set the number of steps for training with max_steps or number of epochs with max_epochs in the trainer's config."""

# lets modify some trainer configs
# checks if we have GPU available and uses it
config.trainer.accelerator = 'gpu' if torch.cuda.is_available() else 'cpu'
config.trainer.devices = 1


# for mixed precision training, uncomment the lines below (precision should be set to 16 and amp_level to O1):
# config.trainer.precision = 16
# config.trainer.amp_level = O1

# disable distributed training when using Colab to prevent the errors
config.trainer.strategy = 'auto'

# setup max number of steps to reduce training time for demonstration purposes of this tutorial
# Training stops when max_step or max_epochs is reached (earliest)
config.trainer.max_epochs = 10

# instantiates a PT Trainer object by using the trainer section of the config
trainer = pl.Trainer(**config.trainer)

"""### Setting up the NeMo Experiment¶

NeMo has an experiment manager that handles the logging and saving checkpoints for us, so let's setup it. We need the PT trainer and the exp_manager config:
"""

# The experiment manager of a trainer object can not be set twice. We repeat the trainer creation code again here to prevent getting error when this cell is executed more than once.
trainer = pl.Trainer(**config.trainer)

# exp_dir specifies the path to store the the checkpoints and also the logs, it's default is "./nemo_experiments"
# You may set it by uncommentig the following line
# config.exp_manager.exp_dir = 'LOG_CHECKPOINT_DIR'

# OmegaConf.to_yaml() is used to create a proper format for printing the trainer config
print(OmegaConf.to_yaml(config.exp_manager))

exp_dir = exp_manager(trainer, config.exp_manager)

# the exp_dir provides a path to the current experiment for easy access
print(exp_dir)

"""Before initializing the model, we might want to modify some of the model configs. For example, we might want to modify the pretrained BERT model to another model. The default model is bert-base-uncased. We support a variety of models including all the models available in HuggingFace, and Megatron."""

# complete list of supported BERT-like models
print(nemo_nlp.modules.get_pretrained_lm_models_list())

"""We used `bert-base-cased` because the sentence in our dataset are cased."""

# specify the BERT-like model, you want to use
# set the `model.language_modelpretrained_model_name' parameter in the config to the model you want to use
config.model.language_model.pretrained_model_name = "bert-base-cased"

"""Now, we are ready to initialize our model. During the model initialization call, the dataset and data loaders will also be prepared for the training and validation.

Also, the pretrained BERT model will be automatically downloaded. Note it can take up to a few minutes depending on the size of the chosen BERT model for the first time you create the model. If your dataset is large, it also may take some time to read and process all the datasets.

Now we can create the model with the model config and the trainer object like this:
"""

model = nemo_nlp.models.TextClassificationModel(cfg=config.model, trainer=trainer)

"""### Monitoring Training Progress

Optionally, you can create a Tensorboard visualization to monitor training progress.

"""

# Commented out IPython magic to ensure Python compatibility.
try:
  from google import colab
  COLAB_ENV = True
except (ImportError, ModuleNotFoundError):
  COLAB_ENV = False

# Load the TensorBoard notebook extension
if COLAB_ENV:
#   %load_ext tensorboard
#   %tensorboard --logdir {exp_dir}
else:
  print("To use tensorboard, please use this notebook in a Google Colab environment.")

"""### Training

You may start the training by using the trainer.fit() method. The number of steps/epochs of the training are specified already in the config of the trainer and you may update them before creating the trainer.
"""

# start model training
trainer.fit(model)
model.save_to(config.save_to)

"""### Evaluation

To see how the model performs, we can run evaluate and test the performance of the trained model on a data file. Here we would load the best checkpoint (the one with the lowest validation loss) and create a model (eval_model) from the checkpoint. We would also create a new trainer (eval_trainer) to show how it is done when training is done and you have just the checkpoints. If you want to perform the evaluation in the same script as the training's script, you may still use the same model and trainer you used for training.
"""

config.model.test_ds.file_path = '/content/DATA_DIR/test.tsv'

"""#### Validation"""

# extract the path of the best checkpoint from the training, you may update it to any checkpoint
checkpoint_path = trainer.checkpoint_callback.best_model_path
# Create an evaluation model and load the checkpoint
eval_model = nemo_nlp.models.TextClassificationModel.load_from_checkpoint(checkpoint_path=checkpoint_path)

# create a dataloader config for evaluation, the same data file provided in validation_ds is used here
# file_path can get updated with any file
eval_config = OmegaConf.create({'file_path': config.model.validation_ds.file_path, 'batch_size': 64, 'shuffle': False, 'num_samples': -1})
eval_model.setup_test_data(test_data_config=eval_config)
#eval_dataloader = eval_model._create_dataloader_from_config(cfg=eval_config, mode='test')

# a new trainer is created to show how to evaluate a checkpoint from an already trained model
# create a copy of the trainer config and update it to be used for final evaluation
eval_trainer_cfg = config.trainer.copy()
eval_trainer_cfg.accelerator = 'gpu' if torch.cuda.is_available() else 'cpu' # it is safer to perform evaluation on single GPU as PT is buggy with the last batch on multi-GPUs
eval_trainer_cfg.strategy = 'auto' # 'ddp' is buggy with test process in the current PT, it looks like it has been fixed in the latest master
eval_trainer = pl.Trainer(**eval_trainer_cfg)

eval_trainer.test(model=eval_model, verbose=False) # test_dataloaders=eval_dataloader,

"""### Test Data"""

checkpoint_path = trainer.checkpoint_callback.best_model_path
# Create an evaluation model and load the checkpoint
eval_model = nemo_nlp.models.TextClassificationModel.load_from_checkpoint(checkpoint_path=checkpoint_path)

# create a dataloader config for evaluation, the same data file provided in validation_ds is used here
# file_path can get updated with any file
eval_config = OmegaConf.create({'file_path': config.model.test_ds.file_path, 'batch_size': 64, 'shuffle': False, 'num_samples': -1})
eval_model.setup_test_data(test_data_config=eval_config)
#eval_dataloader = eval_model._create_dataloader_from_config(cfg=eval_config, mode='test')

# a new trainer is created to show how to evaluate a checkpoint from an already trained model
# create a copy of the trainer config and update it to be used for final evaluation
eval_trainer_cfg = config.trainer.copy()
eval_trainer_cfg.accelerator = 'gpu' if torch.cuda.is_available() else 'cpu' # it is safer to perform evaluation on single GPU as PT is buggy with the last batch on multi-GPUs
eval_trainer_cfg.strategy = 'auto' # 'ddp' is buggy with test process in the current PT, it looks like it has been fixed in the latest master
eval_trainer = pl.Trainer(**eval_trainer_cfg)

eval_trainer.test(model=eval_model, verbose=False) # test_dataloaders=eval_dataloader,

"""### Inference

You may create a model from a saved checkpoint and use the model.infer() method to perform inference on a list of queries. There is no need of any trainer for inference.
"""

# extract the path of the best checkpoint from the training, you may update it to any other checkpoint file
checkpoint_path = trainer.checkpoint_callback.best_model_path
# Create an evaluation model and load the checkpoint
infer_model = nemo_nlp.models.TextClassificationModel.load_from_checkpoint(checkpoint_path=checkpoint_path)

# define the list of queries for inference
#load test data
test_data = pd.read_csv('/content/DATA_DIR/test.tsv', sep='\t', header=None)
seed = np.random.randint(1,21)
random_sentences = test_data.sample(n = 20, random_state = seed)

random_sentences = random_sentences[0].tolist()

random_sentences

# move the model to the desired device for inference
# we move the model to "cuda" if available otherwise "cpu" would be used
if torch.cuda.is_available():
    infer_model.to("cuda")
else:
    infer_model.to("cpu")



# max_seq_length=512 is the maximum length BERT supports.
results = infer_model.classifytext(queries=random_sentences, batch_size=3, max_seq_length=512)

print('The prediction results of some sample queries with the trained model:')
for query, result in zip(random_sentences, results):
    print(f'Query : {query}')
    print(f'Predicted label: {result}')

"""### Deployment"""

!pip install --upgrade onnxruntime

"""Exporting model....."""

model.export(config.export_to)

"""And run some queries"""

import numpy as np
import torch
from nemo.utils import logging
from nemo.collections.nlp.parts.utils_funcs import tensor2list
from nemo.collections.nlp.models.text_classification import TextClassificationModel
from nemo.collections.nlp.data.text_classification import TextClassificationDataset

import onnxruntime

def to_numpy(tensor):
    return tensor.detach().cpu().numpy() if tensor.requires_grad else tensor.cpu().numpy()

def postprocessing(results, labels):
    return [labels[str(r)] for r in results]

def create_infer_dataloader(model, queries):
    batch_size = len(queries)
    dataset = TextClassificationDataset(tokenizer=model.tokenizer, queries=queries, max_seq_length=512)
    return torch.utils.data.DataLoader(
        dataset=dataset,
        batch_size=batch_size,
        shuffle=False,
        num_workers=2,
        pin_memory=True,
        drop_last=False,
        collate_fn=dataset.collate_fn,
    )


queries = random_sentences

model.eval()
infer_datalayer = create_infer_dataloader(model, queries)

ort_session = onnxruntime.InferenceSession(config.export_to, providers=['CPUExecutionProvider'])

for batch in infer_datalayer:
    input_ids, input_type_ids, input_mask, subtokens_mask = batch
    ort_inputs = {ort_session.get_inputs()[0].name: to_numpy(input_ids),
                  ort_session.get_inputs()[1].name: to_numpy(input_mask),
                  ort_session.get_inputs()[2].name: to_numpy(input_type_ids),}
    ologits = ort_session.run(None, ort_inputs)
    alogits = np.asarray(ologits)
    logits = torch.from_numpy(alogits[0])
    preds = tensor2list(torch.argmax(logits, dim = -1))
    processed_results = postprocessing(preds, {"0": "neutral", "1": "positive", "2": "negative"})

    logging.info('The prediction results of some sample queries with the trained model:')
    for query, result in zip(queries, processed_results):
        logging.info(f'Query : {query}')
        logging.info(f'Predicted label: {result}')
    break